# Veritas ≡ Анти-энтропийный двигатель знаний

> «Мы не ищем ошибки; мы подавляем распад».

## 0. TL;DR (30 секунд)

* Любой репозиторий — открытая система → энтропия растёт.
* `veritas check` — акт измерения, возвращающий систему к низкой энтропии: **зелёный Trust-stamp** или отчёт о разрыве договора.
* Одно имя-хэш (`whole.lock`, 12 симв.) — паспорт личности конкретного состояния знания.
* Граф контрактов хранится в `logic-graph.yml` как K-П-С (Контекст-Переход-Свидетельство).

--- depth ---

## 1. Anti-entropy вместо «просто CI»

CI-пайплайн обычно ловит *ошибки*. Veritas измеряет **целостность**. Если хотя бы один контракт нарушен — граф разрывается, энтропия ↑, Trust-stamp меняется.

Формула анти-энтропии:

\[\Delta S_{Veritas} = -k_B \ln(\text{passed} / \text{total})\]

При `passed = total` имеем \(\Delta S = 0\) → информационный «кристалл».

## 2. whole.lock — паспорт личности

```text
whole.lock = SHA-256( sort_keys({nodes, edges}) )[:12]
```

Даёт постоянную ссылку `Δ-Kernel@d5fd4e89`. Сломал контракт — получи новый hash и ответственность.

## 3. Наблюдатель как процесс

Человек определяет границы (K), автомат проверяет свидетельства (С) и фиксирует переходы (П). Это кибернетика 2-го порядка: наблюдатель — тоже процесс.

## 4. Logic-as-a-Service

Declarative API → плагины (pytest, Lean, guardian…). Подобно Terraform: описываем желаемое логическое состояние — Veritas приводит мир к нему.

---

### Что мы **не** утверждаем

* Не гарантируем абсолютную истину, только воспроизводимость графа.
* Не решаем проблему доверия к вычислительной среде (supply chain).
* Не заменяем рецензирование — дополняем.

### FAQ (mini)

**Можно отключить проверки?** Можно, но Trust-stamp изменится → репутационный риск.

**Зачем Lean, если есть тесты?** Тесты — эмпирика, Lean — дедукция; подавляют разные виды распада. 