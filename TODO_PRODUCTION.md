# Production-grade Roadmap for Δ-Kernel Repository

> This document enumerates everything that remains to be converted from the current proof-of-concept into a *fully verifiable, publication-ready* artifact.  It can serve as the team's shared TODO list; CI should fail once any checkbox marked `TODO` is left unchecked in the final release.

## 1  Lean Core

| Block | Current state | Required for "honest = exact" | Technique / code snippet |
|-------|---------------|-------------------------------|---------------------------|
| **Lean core** | 5 `placeholder` theorems; 6 rows of the grand table not covered. | 1. Replace placeholders with formally closed lemmas.<br>2. Add 6 files: `Noether.lean`, `NavierStokes.lean`, `FokkerPlanck.lean`, `GradientDesc.lean`, `Nash.lean`, `FFTGeom.lean`.<br>3. In `TableCorrespondence.lean` use `open`/`export` + `namespace TableProof` so that *Lean* enforces import of every lemma. | **Minimal example (Landauer bound):**
```lean
import Mathlib.Data.Real.Log
open Real

theorem landauer_exact (T : ℝ) (hT : T > 0) :
    (Real.log 2) * T ≥ 0 := by
  have hlog : Real.log 2 > 0 := by
    have : (2 : ℝ) > 1 := by norm_num
    exact Real.log_pos this
  have : 0 ≤ Real.log 2 := le_of_lt hlog
  have : 0 ≤ T := le_of_lt hT
  simpa using mul_nonneg ‹0 ≤ Real.log 2› this
```|

---

## 2  pytest / Numeric demos

| Item | What to add |
|------|-------------|
| Landauer | already covered |
| Shannon | already covered |
| Navier–Stokes | replace placeholder with 15 × 15 2-D Stokes mini-solver (ν = 1). Verify \(\mathrm dE/\mathrm dt + \int F ∇P < 10^{-8}\). |
| Fokker–Planck | Simulate Ornstein–Uhlenbeck chain (σ = 1, θ = 1). Check entropy growth \(\dot S ≥ 0\). |
| Nash | Two-player 2 × 2 bandit via PyTorch gradient descent; assert ‖∇U‖→0 after 100 steps. |
| FFT geometry | Count complex multiplies for `n=2**10`; assert ratio versus \(n^2\) ≈ `log₂ n`. |

Each demo must expose:
```python
def f_dot_grad_p(*params) -> float: ...
def theoretical(*params) -> float: ...
assert np.allclose(f_dot_grad_p(...), theoretical(...))
```
so that the test-runner can discover and tabulate automatically.

---

## 3  Continuous Integration

* `requirements-dev.txt` → numpy, torch (if used), ruff, black.
* GitHub Action matrix `{ ubuntu-latest, macos-latest }`.
* Optional `docker-compose.yml` for local multiplatform reproduction.

---

## 4  Documentation

* Update `README.md` with a machine-generated table "Lean-verified vs Numeric-verified".
* `paper/suppA_lean_outline.tex` to be autogenerated by `gen_lean_index.py`.

---

## 5  Code Quality

* Enforce `ruff` + `black` via *pre-commit* hooks.
* Remove C++ demo; prefer Python + Numba to keep dependency surface consistent.

---

## 6  Neuroscience Energy (Spike)

* In `hh_spike.py` print
  ```text
  bits = ΔE / (k_B * T * ln 2)
  ```
  Compare with literature (≈ 10³ bits per spike).

---

## 7  Repo Concatenation Utility

* Extend `concat_repo.py` with `--sha` flag that appends SHA-256 of every included file for long-term archiving / Zenodo bundles.

---

## 8  Zenodo Release

When CI is ✨ green:
1. Tag version `v0.1`.
2. Upload archive + `repo_concat.txt` to Zenodo.
3. Insert DOI in README, LaTeX main paper, and Abstract.

---

**Checklist (CI to enforce):**
- [ ] All Lean files compile with `0 #sorry`.
- [ ] `pytest` discovers 12 numeric demos and all pass within ≤ 10 seconds each.
- [ ] README table is up-to-date.
- [ ] `repo_concat --sha` passes and includes every Lean/Python file.
- [ ] Zenodo DOI present.

Once all boxes ticked, the repository is a *self-verifying artifact*: one CI run = one published quantitative claim, with no hand-wave. 